# Java 8 Features

Java 8 implemented many new and useful features including

-   Functional Interfaces
-   Lamda Expressions
-   Stream API
-   Reflections API
-   Date and Time API
-   Optional Classes
-   Predicates

# Fuctional Interfaces

Functional interfaces are interfaces with only one abstract method.
- Implicitly created by lambdas
- Can be explicitly created for use by lambdas

# Lamdas:
possibly the biggest addition to Java 8, they introduce important aspects of functional programming, allow for disembodied methods, aka functions


The basic syntax is `parameter(s) -> expression`

For multiple parameters parenthesis are required, for multiple lines of logic in the expression curly braces are required

The return keyword is optional for single expression lambdas

Lambdas are used a lot in conjunction with forEach loops on collections, and with the Streams API to apply perform some logic before passing data to the next stream

# Date and Time API:

Before Java 8 Dates and Times were separate, represented by java.util.Date and java.util.Calendar, and there were issues with these classes

Java introduced a new APU through the java.time package which includes:

-   LocalDate - only contains date information
-   LocalTime - only contains time information
-   LocalDateTime - contains a date and time
-   ZonedDateTime - for working with time zones
-   Period - represents a quantity of time (years, months, days)
-   Duration - represents quantity of time (seconds, nanoseconds)
-   DateTimeFormatter - for representing dates/times in a given format

## DateTimeFormatter

Provides Static Variables, and other methods to parse and format dates and times in just about everyway imagineable

## Optional Class:

The optional class was introduced to reduce the need for excessive null value checking

An Optional is a wrapper object which may or may not contain a value, with a few helpful helper methods

They are useful as replacements for null values when returning an empty response from a method

Example:

```java
public class OptionalExample {
  public Optional<String> getAmbiguousString(boolean b) {
    if (true) {
	  return Optional.of("awesome string!");
	} else {
	  return Optional.empty();
	}
  }
  public static void main(String[] args) {
    Optional<String> optString = getAmbiguousString(false);
	String theString = optString.orElse(""); // specify a fallback value
	System.out.println(theString);
	// we can use the String without fear of NullPointerException now
  }
}
```

# Stream API

The Stream API is a functional-style of defining operations on a stream of elements.

-   Streams are an abstraction which allow defining operations which do not modify the source data, and are lazily loaded

Streams do not store data, they simply operate on data, like filtering, mapping, or reducing it

Streams are divided into two streams:

-   Intermediate, return a new stream and are always lazy, they don't execute until the terminal operation is called
-   Terminal, trigger the execution of the stream pipeline, which allows effiecency by performing all operations in a single pass over the data

Reduction operations take a sequence of elements and combine them into a single result

-   .reduce() and .collect() are implemented by many Stream classes for this purpose

Example:

```java
List<Student> students = new ArrayList<>();
// add students...
List<Double> grades = students.stream()
                          .filter(s -> s.isAttending())
						  .mapToDouble(s -> s.getGrade)
						  .collect(Collectors.toList());
```