package com.example.tests.services;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.example.models.GroceryItem;
import com.example.repository.GroceryMockRepo;
import com.example.services.GroceryService;

/*
 * Intro to TDD
 * Test Driven Development is the process of writing tests first, then writing code to pass those tests
 * - This will help increase code coverage
 * 		- The percentage of lines/methods/classes that are tested
 * 
 * Red/Green Testing
 * - A process of writing a test, running it, (which fails aka red)
 * - Then writing some code to pass that specific test (which passes aka green)
 * - Writing a more specific test and running (fails aka red)
 * - Refactoring your code to pass that test (passes aka green) all the way until you have the wanted logic
 * 
 * Maybe you are writing a calculator
 * 1. test if 1 + 1 = 2 -> run the test and it fails
 * 2. You right the addition method to just return 2
 * 3. You rerun the 1 + 1 test and it passes
 * 4. You a new test 1+2 -> run it and its going fail
 * 5. Refactor addition method to pass tests 1 and 2
 * 6. Run the 1+2 test and it should pass both tests resulting in green
 * 
 */
public class UserServiceTest {
	
	/*
	 * Unit Testing, is the testing of indicidual software components in isolation from the rest of the software
	 * 
	 * It also sometimes be referred to as Whitebox testing
	 * 	- Testing where you know the internal design of the module you are testing
	 * 
	 * Unit testing can find if/when something goes wrong in your code
	 * - reduce debugging time, because you know where to look in your code
	 * - It increases code coverage, because you should be testing each individual component/module
	 * - It increases confidence in code changing and maintenance
	 * 
	 * How to write Unit tests in Java
	 * - We use a library called JUnit
	 * 
	 * JUnit comes with Annotations and static assertion methods to test whether our code acts as it should
	 * 
	 */
	
	//We want to mock the functionality of our repo, so we are not actually hitting out db
	@Mock
	private static GroceryMockRepo mockRepo;
	
	//Our groceryService requires our mockRepo so we will inject that mock into the groceryService
	@InjectMocks
	private static GroceryService groceryService;
	
	//The annotion @BeforeClass will run once before the entire test suite runs
	@BeforeClass
	public static void setupBeforeClass() {
		System.out.println("Maybe we do some setup");
//		mockRepo = new GroceryMockRepo();
//		groceryService = new GroceryService(mockRepo);
	}
	
	//The annotation @Before will run once before every test
	@Before
	public void setupBeforeTestMethods() {
		//Setup our  test to use Mockito mock annotations
		MockitoAnnotations.openMocks(this);
		System.out.println("This will run before every method in this class");
	}
	
	//The annotation @After will run once after every test
	@After
	public void tearDownAfterTestMethods() {
		System.out.println("This will run once after every method in this class");
	}
	
	//The annotation @AfterClass will run once after the entire test suite
	@AfterClass
	public static void tearDownAfterEntireClass() {
		System.out.println("This will run once after the entire class is finished");
	}
	
	//The @Test annotation is how we will actually mark a method as a test
	//@Ignore will not run this test
	@Ignore
	@Test
	public void testCreateItem() {
		//Run the logic that we want to test and then verify the correct outcome
		//When we run groceryService.add we expect there to be one extra item in the repo
		//And we expect the item info to be correct
		GroceryItem expectedItem = new GroceryItem(1, "Test", 1.00, "TestType");
		
		//The id is being generated by the db
		//We have run the logic we want to test, now we want to make the value returned is correct
		//We are ONLY testing the groceryService, NOT the groceryRepo
		GroceryItem actualItem = groceryService.createNewItem("Test", 1.00, "TestType");
		
		//We want to test to make sure the groceryItem service returned the item we expected
		//To test this we have assertion methods
		//The assertEquals can take in a message, the expectedValue, actualValue
		assertEquals("The item should be created correctly", expectedItem, actualItem);
	}
	
	/* With our unit tests, we really want to get rid of all dependencies and only test the specific
	 * modules without them
	 * To do this we do something called mocking
	 * - This allows us to mock/fake the functionality of other dependencies
	 * - Imagine you are testing this application, and you are connected to a real database
	 * 		- So we can use use a mocked version of our repo, to return data without hitting the database
	 * 
	 * Mocking allows for Black Box testing in Java
	 * - This is where we don't know the functionality/don't care about the functionality, we just want the data
	 * 	- We dont care how we get the data, we just want to ensure the data is correct for the module we are testing
	 * - We will replace our dependencies in unit tests with mocks and stubs (we will replace the groceryRepo with a mock)
	 * 
	 * Stub is a fake class that comes with preprogrammed return values
	 * 
	 * Mock is a fake class that can be examined after the test is finished to see how it interacted with the rest of
	 * the system
	 * 
	 * The way we will mock in Java tests is with a library called Mockito
	 * - Is going to use annotations to implement its mocking
	 * - To mock an object we use @Mock
	 * 		- Mocking objects gives you the ability to prevent the object from doing something, and you get tell
	 * 			it what to do instead
	 * 		- Useful when one peice of code relies on another
	 * 
	 * If you have a object that requires another one, we need to use @InjectMocks, to inject the mocked object
	 * 	into the object we are testing
	 * 
	 * Finally, to be sure the mocking is going to work/is setup, we need to enable the mockito annotations in the
	 * 	@Before method
	 * 
	 */
	@Test
	public void testGetAllItems() {
		//We can use some of the static methods that come with mockito to explain/describe what we want to happen when
		//a mocked object gets called
		Collection<GroceryItem> collection = new ArrayList<>();
		collection.add(new GroceryItem(1, "Test", 1.99, "TestType"));
		
		//When we make a call to mockRepo.getAllItems() do NOT do the actual logic, rather return a set list of items
		when(mockRepo.getAllItems()).thenReturn(collection);
		
		List<GroceryItem> actualItems = groceryService.getAllItems();
		
		//Lets first check that the size is 1
		assertEquals(1, actualItems.size());
	}
}
