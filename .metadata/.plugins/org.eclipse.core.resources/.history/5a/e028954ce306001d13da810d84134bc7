package com.revature.eval.java.core;

import java.io.BufferedReader;
import java.io.Reader;
import java.io.StringReader;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EvaluationService {

	/**
	 * 1. Without using the StringBuilder or StringBuffer class, write a method that
	 * reverses a String. Example: reverse("example"); -> "elpmaxe"
	 * 
	 * @param string
	 * @return
	 */
	public String reverse(String string) {
		return null;
	}

	/**
	 * 2. Convert a phrase to its acronym. Techies love their TLA (Three Letter
	 * Acronyms)! Help generate some jargon by writing a program that converts a
	 * long name like Portable Network Graphics to its acronym (PNG).
	 * 
	 * @param phrase
	 * @return
	 */
	public String acronym(String phrase) {
		return null;
	}

	/**
	 * 3. Determine if a triangle is equilateral, isosceles, or scalene. An
	 * equilateral triangle has all three sides the same length. An isosceles
	 * triangle has at least two sides the same length. (It is sometimes specified
	 * as having exactly two sides the same length, but for the purposes of this
	 * exercise we'll say at least two.) A scalene triangle has all sides of
	 * different lengths.
	 *
	 */
	static class Triangle {
		private double sideOne;
		private double sideTwo;
		private double sideThree;

		public Triangle() {
			super();
		}

		public Triangle(double sideOne, double sideTwo, double sideThree) {
			this();
			this.sideOne = sideOne;
			this.sideTwo = sideTwo;
			this.sideThree = sideThree;
		}

		public double getSideOne() {
			return sideOne;
		}

		public void setSideOne(double sideOne) {
			this.sideOne = sideOne;
		}

		public double getSideTwo() {
			return sideTwo;
		}

		public void setSideTwo(double sideTwo) {
			this.sideTwo = sideTwo;
		}

		public double getSideThree() {
			return sideThree;
		}

		public void setSideThree(double sideThree) {
			this.sideThree = sideThree;
		}

		public boolean isEquilateral() {
			if (sideOne == sideTwo && sideTwo == sideThree) {
				return true;
			}
			return false;
		}

		public boolean isIsosceles() {
			if (sideOne == sideTwo || sideTwo == sideThree || sideThree == sideOne) {
				return true;
			}

			return false;
		}

		public boolean isScalene() {
			if (sideOne != sideTwo && sideTwo != sideThree) {
				return true;
			}
			return false;
		}

	}

	/**
	 * 4. Given a word, compute the scrabble score for that word.
	 * 
	 * --Letter Values-- Letter Value A, E, I, O, U, L, N, R, S, T = 1; D, G = 2; B,
	 * C, M, P = 3; F, H, V, W, Y = 4; K = 5; J, X = 8; Q, Z = 10; Examples
	 * "cabbage" should be scored as worth 14 points:
	 * 
	 * 3 points for C, 1 point for A, twice 3 points for B, twice 2 points for G, 1
	 * point for E And to total:
	 * 
	 * 3 + 2*1 + 2*3 + 2 + 1 = 3 + 2 + 6 + 3 = 5 + 9 = 14
	 * 
	 * @param string
	 * @return
	 */
	public int getScrabbleScore(String string) {
		HashMap<Character, Integer> scoreKey = new HashMap<Character, Integer>();
		scoreKey.put('A', 1);
		scoreKey.put('E', 1);
		scoreKey.put('I', 1);
		scoreKey.put('O', 1);
		scoreKey.put('U', 1);
		scoreKey.put('L', 1);
		scoreKey.put('N', 1);
		scoreKey.put('R', 1);
		scoreKey.put('S', 1);
		scoreKey.put('T', 1);
		scoreKey.put('D', 2);
		scoreKey.put('G', 2);
		scoreKey.put('B', 3);
		scoreKey.put('C', 3);
		scoreKey.put('M', 3);
		scoreKey.put('P', 3);
		scoreKey.put('F', 4);
		scoreKey.put('H', 4);
		scoreKey.put('V', 4);
		scoreKey.put('W', 4);
		scoreKey.put('Y', 4);
		scoreKey.put('K', 5);
		scoreKey.put('J', 8);
		scoreKey.put('X', 8);
		scoreKey.put('Z', 10);
		scoreKey.put('Q', 10);

		int score = 0;
		String check = string.toUpperCase();

		for (int i = 0; i < check.length(); i++) {
			score += scoreKey.get(check.charAt(i));
		}

		return score;
	}

	/**
	 * 5. Clean up user-entered phone numbers so that they can be sent SMS messages.
	 * 
	 * The North American Numbering Plan (NANP) is a telephone numbering system used
	 * by many countries in North America like the United States, Canada or Bermuda.
	 * All NANP-countries share the same international country code: 1.
	 * 
	 * NANP numbers are ten-digit numbers consisting of a three-digit Numbering Plan
	 * Area code, commonly known as area code, followed by a seven-digit local
	 * number. The first three digits of the local number represent the exchange
	 * code, followed by the unique four-digit number which is the subscriber
	 * number.
	 * 
	 * The format is usually represented as
	 * 
	 * 1 (NXX)-NXX-XXXX where N is any digit from 2 through 9 and X is any digit
	 * from 0 through 9.
	 * 
	 * Your task is to clean up differently formatted telephone numbers by removing
	 * punctuation and the country code (1) if present.
	 * 
	 * For example, the inputs
	 * 
	 * +1 (613)-995-0253 613-995-0253 1 613 995 0253 613.995.0253 should all produce
	 * the output
	 * 
	 * 6139950253
	 * 
	 * Note: As this exercise only deals with telephone numbers used in
	 * NANP-countries, only 1 is considered a valid country code.
	 */
	public String cleanPhoneNumber(String string) {
		String clean;

		// Regex that detects non-numbers, and use .replaceAll to replace non-numbers
		// with empty character
		clean = string.replaceAll("[^0-9]+", "");

		// Check if the phone number is either 11 or 10 digits long
		if (clean.length() != 11 && clean.length() != 10) {
			throw new IllegalArgumentException();
		}
		// If the length is 10, the first digit must be greater than 1
		else if (clean.length() < 11 && clean.charAt(0) <= 1) {
			throw new IllegalArgumentException();
		}
		// If the length is 11, then the first digit must be 1
		else if (clean.length() == 11 && clean.charAt(0) != 1) {
			throw new IllegalArgumentException();
		}
		// Otherwise the number is legit
		else
			return clean.toString();
	}

	/**
	 * 6. Given a phrase, count the occurrences of each word in that phrase.
	 * 
	 * For example for the input "olly olly in come free" olly: 2 in: 1 come: 1
	 * free: 1
	 * 
	 * @param string
	 * @return
	 */
	public Map<String, Integer> wordCount(String string) {
		Map<String, Integer> res = new HashMap<String, Integer>();
		
		//Using Regex split the words by anything that is not a character
		String[] words = string.split("[^0-9a-zA-Z]+");
		
		//Go through the list of separated words and check to see if the current word is located in the map, if not add it, if it is increment the value by one.
		for (int i = 0; i < words.length; i++) {
			if (res.containsKey(words[i])) {
				int count = res.get(words[i]);
				res.replace(words[i], count, ++count);
			} else {
				res.put(words[i], 1);
			}
		}
		return res;
	}

	/**
	 * 7. Implement a binary search algorithm.
	 * 
	 * Searching a sorted collection is a common task. A dictionary is a sorted list
	 * of word definitions. Given a word, one can find its definition. A telephone
	 * book is a sorted list of people's names, addresses, and telephone numbers.
	 * Knowing someone's name allows one to quickly find their telephone number and
	 * address.
	 * 
	 * If the list to be searched contains more than a few items (a dozen, say) a
	 * binary search will require far fewer comparisons than a linear search, but it
	 * imposes the requirement that the list be sorted.
	 * 
	 * In computer science, a binary search or half-interval search algorithm finds
	 * the position of a specified input value (the search "key") within an array
	 * sorted by key value.
	 * 
	 * In each step, the algorithm compares the search key value with the key value
	 * of the middle element of the array.
	 * 
	 * If the keys match, then a matching element has been found and its index, or
	 * position, is returned.
	 * 
	 * Otherwise, if the search key is less than the middle element's key, then the
	 * algorithm repeats its action on the sub-array to the left of the middle
	 * element or, if the search key is greater, on the sub-array to the right.
	 * 
	 * If the remaining array to be searched is empty, then the key cannot be found
	 * in the array and a special "not found" indication is returned.
	 * 
	 * A binary search halves the number of items to check with each iteration, so
	 * locating an item (or determining its absence) takes logarithmic time. A
	 * binary search is a dichotomic divide and conquer search algorithm.
	 * 
	 */
	static class BinarySearch<T>{
		private List<T> sortedList;

		public int indexOf(T t) {
			
			return Collections.binarySearch(sortedList, t, null);
		}
		
		public BinarySearch(List<T> sortedList) {
			super();
			this.sortedList = sortedList;
		}

		public List<T> getSortedList() {
			return sortedList;
		}

		public void setSortedList(List<T> sortedList) {
			this.sortedList = sortedList;
		}

	}

	/**
	 * 8. Implement a program that translates from English to Pig Latin.
	 * 
	 * Pig Latin is a made-up children's language that's intended to be confusing.
	 * It obeys a few simple rules (below), but when it's spoken quickly it's really
	 * difficult for non-children (and non-native speakers) to understand.
	 * 
	 * Rule 1: If a word begins with a vowel sound, add an "ay" sound to the end of
	 * the word. Rule 2: If a word begins with a consonant sound, move it to the end
	 * of the word, and then add an "ay" sound to the end of the word. There are a
	 * few more rules for edge cases, and there are regional variants too.
	 * 
	 * See http://en.wikipedia.org/wiki/Pig_latin for more details.
	 * 
	 * @param string
	 * @return
	 */
	public String toPigLatin(String string) {
		
		//Using Regex split the words by anything that is not a character
		String[] words = string.split(" ");
		
		StringBuilder sb = new StringBuilder();
		
		for(int i=0; i<words.length; i++) {
			if(words[i].charAt(0) == 'a' || words[i].charAt(0) == 'e' || words[i].charAt(0) == 'i' || words[i].charAt(0) == 'o' || words[i].charAt(0) == 'u') {
				sb.append(words[i]);
				sb.append("ay");
			}
			else {
				int count = 0;
				int index = 0;
				char cur = ' ';
				while(cur != 'a' && cur != 'e' && cur != 'i' && cur != 'o' && cur != 'u') {
					cur = words[i].charAt(index);
					count++;
					index++;
				}
				if(cur == 'u' && words[i].charAt(index) == 'i') {
					sb.append(words[i].substring(index, words[i].length()));
					sb.append(words[i].substring(0, index));
					sb.append("ay");
				}
				else {
					sb.append(words[i].substring(index -1, words[i].length()));
					sb.append(words[i].substring(0, index-1));
					sb.append("ay");
				}
			}
			
			if(words.length > 1 && i < words.length-1) {
				sb.append(" ");
			}
			
		}
		
		return sb.toString();
	}

	/**
	 * 9. An Armstrong number is a number that is the sum of its own digits each
	 * raised to the power of the number of digits.
	 * 
	 * For example:
	 * 
	 * 9 is an Armstrong number, because 9 = 9^1 = 9 10 is not an Armstrong number,
	 * because 10 != 1^2 + 0^2 = 2 153 is an Armstrong number, because: 153 = 1^3 +
	 * 5^3 + 3^3 = 1 + 125 + 27 = 153 154 is not an Armstrong number, because: 154
	 * != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190 Write some code to determine whether
	 * a number is an Armstrong number.
	 * 
	 * @param input
	 * @return
	 */
	public boolean isArmstrongNumber(int input) {
		ArrayList<Integer> arr = new ArrayList<Integer>();
		int sum = 0;
		int num = input;
		while(num > 0) {
			arr.add(num % 10);
			num = num / 10;
		}
		
		for(int i=0; i<arr.size(); i++) {
			sum += Math.pow(arr.get(i), arr.size());
		}
		
		if(sum == input) {
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * 10. Compute the prime factors of a given natural number.
	 * 
	 * A prime number is only evenly divisible by itself and 1.
	 * 
	 * Note that 1 is not a prime number.
	 * 
	 * @param l
	 * @return
	 */
	public List<Long> calculatePrimeFactorsOf(long l) {
		//We dont want to modify the input long, so we copy it over to a new var
		long num = l;
		List<Long> ret = new ArrayList<Long>();
		
		for(long i = 2l; i<=num; i++) {
			while(num%i == 0) {
				ret.add(i);
				num = num/i;
			}
		}
		
		return ret;
	}

	/**
	 * 11. Create an implementation of the rotational cipher, also sometimes called
	 * the Caesar cipher.
	 * 
	 * The Caesar cipher is a simple shift cipher that relies on transposing all the
	 * letters in the alphabet using an integer key between 0 and 26. Using a key of
	 * 0 or 26 will always yield the same output due to modular arithmetic. The
	 * letter is shifted for as many values as the value of the key.
	 * 
	 * The general notation for rotational ciphers is ROT + <key>. The most commonly
	 * used rotational cipher is ROT13.
	 * 
	 * A ROT13 on the Latin alphabet would be as follows:
	 * 
	 * Plain: abcdefghijklmnopqrstuvwxyz Cipher: nopqrstuvwxyzabcdefghijklm It is
	 * stronger than the Atbash cipher because it has 27 possible keys, and 25
	 * usable keys.
	 * 
	 * Ciphertext is written out in the same formatting as the input including
	 * spaces and punctuation.
	 * 
	 * Examples: ROT5 omg gives trl ROT0 c gives c ROT26 Cool gives Cool ROT13 The
	 * quick brown fox jumps over the lazy dog. gives Gur dhvpx oebja sbk whzcf bire
	 * gur ynml qbt. ROT13 Gur dhvpx oebja sbk whzcf bire gur ynml qbt. gives The
	 * quick brown fox jumps over the lazy dog.
	 */
	static class RotationalCipher {
		private int key;

		public RotationalCipher(int key) {
			super();
			this.key = key;
		}

		public String rotate(String string) {
			
			//Setup
			HashMap<Character, Integer> charNumSet = new HashMap<Character, Integer>();
			char[] alphabet = {'a','b','c','d','e','f','g','h', 'i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
			charNumSet.put('a', 1);
			charNumSet.put('b', 2);
			charNumSet.put('c', 3);
			charNumSet.put('d', 4);
			charNumSet.put('e', 5);
			charNumSet.put('f', 6);
			charNumSet.put('g', 7);
			charNumSet.put('h', 8);
			charNumSet.put('i', 9);
			charNumSet.put('j', 10);
			charNumSet.put('k', 11);
			charNumSet.put('l', 12);
			charNumSet.put('m', 13);
			charNumSet.put('n', 14);
			charNumSet.put('o', 15);
			charNumSet.put('p', 16);
			charNumSet.put('q', 17);
			charNumSet.put('r', 18);
			charNumSet.put('s', 19);
			charNumSet.put('t', 20);
			charNumSet.put('u', 21);
			charNumSet.put('v', 22);
			charNumSet.put('w', 23);
			charNumSet.put('x', 24);
			charNumSet.put('y', 25);
			charNumSet.put('z', 26);
			
			String ret = "";
			int resIndex;
			
			for(int i=0; i<string.length(); i++) {
				char current = string.charAt(i);
				if(current == ' ') {
					ret+= current;
				}
				else if(Character.isDigit(current)) {
					ret+=current;
				}
				else if(current == '.' || current == '!' || current == 39 || current == ',') {
					ret+=current;
				}
				else if(Character.isUpperCase(current)) {
					char lower = Character.toLowerCase(current);
					int cipherLetterIndex = charNumSet.get(lower);
					int cipherPlusKey = cipherLetterIndex + key;
					if(cipherPlusKey > 26) {
						resIndex = cipherPlusKey - 26;
					}
					else {
						resIndex = cipherPlusKey;
					}
					
					ret+= Character.toUpperCase(alphabet[resIndex-1]);
				}
				else {
					int cipherLetterIndex = charNumSet.get(current);
					int cipherPlusKey = cipherLetterIndex + key;
					if(cipherPlusKey > 26) {
						resIndex = cipherPlusKey - 26;
					}
					else {
						resIndex = cipherPlusKey;
					}
					
					ret+= alphabet[resIndex-1];
				}
			}
			return ret;
		}

	}

	/**
	 * 12. Given a number n, determine what the nth prime is.
	 * 
	 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
	 * that the 6th prime is 13.
	 * 
	 * If your language provides methods in the standard library to deal with prime
	 * numbers, pretend they don't exist and implement them yourself.
	 * 
	 * @param i
	 * @return
	 */
	public int calculateNthPrime(int i) {
		
		int count = 0;
		int num = 1;
		int j;
		
		if(i < 1) {
			throw new IllegalArgumentException();
		}
		
		while(count < i) {
			num+=1;
			for(j = 2; j<=num; j++) {
				if(num % j == 0) {
					break;
				}
			}
			if(j == num) {
				count+=1;
			}
		}
		
		
		return num;
	}

	/**
	 * 13 & 14. Create an implementation of the atbash cipher, an ancient encryption
	 * system created in the Middle East.
	 * 
	 * The Atbash cipher is a simple substitution cipher that relies on transposing
	 * all the letters in the alphabet such that the resulting alphabet is
	 * backwards. The first letter is replaced with the last letter, the second with
	 * the second-last, and so on.
	 * 
	 * An Atbash cipher for the Latin alphabet would be as follows:
	 * 
	 * Plain: abcdefghijklmnopqrstuvwxyz Cipher: zyxwvutsrqponmlkjihgfedcba It is a
	 * very weak cipher because it only has one possible key, and it is a simple
	 * monoalphabetic substitution cipher. However, this may not have been an issue
	 * in the cipher's time.
	 * 
	 * Ciphertext is written out in groups of fixed length, the traditional group
	 * size being 5 letters, and punctuation is excluded. This is to make it harder
	 * to guess things based on word boundaries.
	 * 
	 * Examples Encoding test gives gvhg Decoding gvhg gives test Decoding gsvjf
	 * rxpyi ldmul cqfnk hlevi gsvoz abwlt gives thequickbrownfoxjumpsoverthelazydog
	 *
	 */
	static class AtbashCipher {

		/**
		 * Question 13
		 * 
		 * @param string
		 * @return
		 */
		static HashMap<Character, Integer> charNumSet = new HashMap<Character, Integer>();
		
		static String backwardsAlphabet = "zyxwvutsrqponmlkjihgfedcba";
		
		public static void setupHash(HashMap<Character, Integer> hash) {
			hash.put('a', 1);
			hash.put('b', 2);
			hash.put('c', 3);
			hash.put('d', 4);
			hash.put('e', 5);
			hash.put('f', 6);
			hash.put('g', 7);
			hash.put('h', 8);
			hash.put('i', 9);
			hash.put('j', 10);
			hash.put('k', 11);
			hash.put('l', 12);
			hash.put('m', 13);
			hash.put('n', 14);
			hash.put('o', 15);
			hash.put('p', 16);
			hash.put('q', 17);
			hash.put('r', 18);
			hash.put('s', 19);
			hash.put('t', 20);
			hash.put('u', 21);
			hash.put('v', 22);
			hash.put('w', 23);
			hash.put('x', 24);
			hash.put('y', 25);
			hash.put('z', 26);
		}
		
		public static String encode(String string) {
			setupHash(charNumSet);
			
			String ret = "";
			int letterCount = 0;
			for(int i=0; i<string.length(); i++) {
				char cur = string.charAt(i);
				if(Character.isDigit(cur)) {
					ret+= cur;
					++letterCount;
				}
				else if(cur == ' ' || cur == '.' || cur == '!' || cur == 39 || cur == ',') {
					continue;
				}
				else if(Character.isUpperCase(cur)) {
					
					if(letterCount % 5 == 0 && letterCount !=0) {
						ret+= " ";
					}
					
					char lower = Character.toLowerCase(cur);
					int index = charNumSet.get(lower);
					ret+= backwardsAlphabet.charAt(index-1);
					++letterCount;
				}
				else {
					
					if(letterCount % 5 == 0 && letterCount !=0) {
						ret+= " ";
					}
					
					int index = charNumSet.get(cur);
					ret+= backwardsAlphabet.charAt(index-1);
					++letterCount;
				}
			}
			return ret;
		}

		/**
		 * Question 14
		 * 
		 * @param string
		 * @return
		 */
		public static String decode(String string) {

			setupHash(charNumSet);
			
			String ret = "";
			for(int i=0; i<string.length(); i++) {
				char cur = string.charAt(i);
				if(Character.isDigit(cur)) {
					ret+= cur;
				}
				else if(cur == ' ' || cur == '.' || cur == '!' || cur == 39 || cur == ',') {
					continue;
				}
				else {
					int index = charNumSet.get(cur);
					ret+= backwardsAlphabet.charAt(index-1);
				}
			}
			
			return ret;
		}
	}

	/**
	 * 15. The ISBN-10 verification process is used to validate book identification
	 * numbers. These normally contain dashes and look like: 3-598-21508-8
	 * 
	 * ISBN The ISBN-10 format is 9 digits (0 to 9) plus one check character (either
	 * a digit or an X only). In the case the check character is an X, this
	 * represents the value '10'. These may be communicated with or without hyphens,
	 * and can be checked for their validity by the following formula:
	 * 
	 * (x1 * 10 + x2 * 9 + x3 * 8 + x4 * 7 + x5 * 6 + x6 * 5 + x7 * 4 + x8 * 3 + x9
	 * * 2 + x10 * 1) mod 11 == 0 If the result is 0, then it is a valid ISBN-10,
	 * otherwise it is invalid.
	 * 
	 * Example Let's take the ISBN-10 3-598-21508-8. We plug it in to the formula,
	 * and get:
	 * 
	 * (3 * 10 + 5 * 9 + 9 * 8 + 8 * 7 + 2 * 6 + 1 * 5 + 5 * 4 + 0 * 3 + 8 * 2 + 8 *
	 * 1) mod 11 == 0 Since the result is 0, this proves that our ISBN is valid.
	 * 
	 * @param string
	 * @return
	 */
	public boolean isValidIsbn(String string) {
		//first we want to strip the string of any -, we can also check for any non-digits that arent x and if the string is larger than 10
		String stripped = "";
		for(int i =0; i< string.length(); i++) {
			char cur = string.charAt(i);
			if(Character.isDigit(cur)) {
				stripped+=cur;
			}
			else if(cur == 'X') {
				stripped+=cur;
			}
		}
		
		if(stripped.length() > 10) {
			return false;
		}
		else {
			int sum = 0;
			int multi = 10;
			
			for(int i=0; i<stripped.length(); i++) {
				if(Character.isDigit(stripped.charAt(i))) {
					int num = Character.getNumericValue(stripped.charAt(i));
					sum+=(num*multi);
					multi--;
				}
				else {
					sum+=(10*multi);
				}
			}
			if(sum%11 == 0) {
				return true;
			}
			else {
				return false;
			}
		}
	}

	/**
	 * 16. Determine if a sentence is a pangram. A pangram (Greek: pan gramma,
	 * "every letter") is a sentence using every letter of the alphabet at least
	 * once. The best known English pangram is:
	 * 
	 * The quick brown fox jumps over the lazy dog.
	 * 
	 * The alphabet used consists of ASCII letters a to z, inclusive, and is case
	 * insensitive. Input will not contain non-ASCII symbols.
	 * 
	 * @param string
	 * @return
	 */
	public boolean isPangram(String string) {
		HashMap<Character, Integer> dict = new HashMap<Character, Integer>();
		int count = 0;
		
		for(int i=0; i<string.length(); i++) {
			char cur = string.charAt(i);
			//If the character doesnt exist in the dictionary
			if(!dict.containsKey(cur) && cur != ' ') {
				//Add it and increment count by 1
				dict.put(cur, 1);
				count++;
			}
		}
		
		if(count == 26) {
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * 17. Given a number, find the sum of all the unique multiples of particular
	 * numbers up to but not including that number.
	 * 
	 * If we list all the natural numbers below 20 that are multiples of 3 or 5, we
	 * get 3, 5, 6, 9, 10, 12, 15, and 18.
	 * 
	 * The sum of these multiples is 78.
	 * 
	 * @param i
	 * @param set
	 * @return
	 */
	public int getSumOfMultiples(int i, int[] set) {
		ArrayList<Integer> multiples = new ArrayList<Integer>();
		int sum = 0;
		for(int j=0; j<set.length; j++) {
			int num = set[j];
			boolean done = false;
			int count = 1;
			while(!done) {
				int toAdd = num * count;
				if(!multiples.contains(toAdd) && toAdd < i) {
					multiples.add(toAdd);
					count++;
				}
				else if(multiples.contains(toAdd) && toAdd < i) {
					count++;
				}
				else {
					done = true;
				}
			}
		}
		
		for(int j=0; j<multiples.size(); j++) {
			sum+=multiples.get(j);
		}
		
		return sum;
	}

	/**
	 * 18. Given a number determine whether or not it is valid per the Luhn formula.
	 * 
	 * The Luhn algorithm is a simple checksum formula used to validate a variety of
	 * identification numbers, such as credit card numbers and Canadian Social
	 * Insurance Numbers.
	 * 
	 * The task is to check if a given string is valid.
	 * 
	 * Validating a Number Strings of length 1 or less are not valid. Spaces are
	 * allowed in the input, but they should be stripped before checking. All other
	 * non-digit characters are disallowed.
	 * 
	 * Example 1: valid credit card number 1 4539 1488 0343 6467 The first step of
	 * the Luhn algorithm is to double every second digit, starting from the right.
	 * We will be doubling
	 * 
	 * 4_3_ 1_8_ 0_4_ 6_6_ If doubling the number results in a number greater than 9
	 * then subtract 9 from the product. The results of our doubling:
	 * 
	 * 8569 2478 0383 3437 Then sum all of the digits:
	 * 
	 * 8+5+6+9+2+4+7+8+0+3+8+3+3+4+3+7 = 80 If the sum is evenly divisible by 10,
	 * then the number is valid. This number is valid!
	 * 
	 * Example 2: invalid credit card number 1 8273 1232 7352 0569 Double the second
	 * digits, starting from the right
	 * 
	 * 7253 2262 5312 0539 Sum the digits
	 * 
	 * 7+2+5+3+2+2+6+2+5+3+1+2+0+5+3+9 = 57 57 is not evenly divisible by 10, so
	 * this number is not valid.
	 * 
	 * @param string
	 * @return
	 */
	public boolean isLuhnValid(String string) {
		//Strip the string of spaces, if it contains anything other than a space or number it is invalid
		//After stripping, start at the right end, take every 2nd number and double it, if that number is greater
		//than 9 subtract nine from it, place those doubled numbers back in the string
		//Take the string and add all the numbers, divide by 10, and if the remainder is 0 its valid
		
		String stripped = "";
		
		for(int i=0; i<string.length(); i++) {
			char cur = string.charAt(i);
			if(!Character.isDigit(cur) && cur != ' ') {
				return false;
			}
			if(Character.isDigit(cur)) {
				stripped+=cur;
			}
		}
		
		int count = 1;
		ArrayList<Integer> backwards = new ArrayList<Integer>();
		for(int i=stripped.length()-1; i>=0; i--) {
			int toAdd;
			int num = Character.getNumericValue(stripped.charAt(i));
			if(count %2 == 0) {
				int doubled = num*2;
				if(doubled > 9) {
					doubled-=9;
				}
				toAdd = doubled;
			} else {
				toAdd = num;
			}
			backwards.add(toAdd);
			
			count++;
		}
		int sum =0;
		for(int i=0; i<backwards.size(); i++) {
			sum+=backwards.get(i);
		}
		
		if(sum%10 == 0) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * 19. Parse and evaluate simple math word problems returning the answer as an
	 * integer.
	 * 
	 * Add two numbers together.
	 * 
	 * What is 5 plus 13?
	 * 
	 * 18
	 * 
	 * Now, perform the other three operations.
	 * 
	 * What is 7 minus 5?
	 * 
	 * 2
	 * 
	 * What is 6 multiplied by 4?
	 * 
	 * 24
	 * 
	 * What is 25 divided by 5?
	 * 
	 * 5
	 * 
	 * @param string
	 * @return
	 */
	public int solveWordProblem(String string) {
		
		String[] words = string.split(" ");
		
		switch(words[3]) {
			case "multiplied":
				return Integer.parseInt(words[2]) * Integer.parseInt(words[5].replace("?",""));
			case "divided":
				return Integer.parseInt(words[2]) / Integer.parseInt(words[5].replace("?",""));
			case "plus":
				return Integer.parseInt(words[2]) + Integer.parseInt(words[4].replace("?",""));
			case "minus":
				return Integer.parseInt(words[2]) - Integer.parseInt(words[4].replace("?",""));
			default:
				return 0;
		}
	}

}
